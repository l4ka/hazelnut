include l4pre.inc 
  
  
  Copyright IBM, L4.IPCMAN.5, 25,07,97, 302, K
 
 
;*********************************************************************
;******                                                         ******
;******         IPC Manager                                     ******
;******                                                         ******
;******                                   Author:   J.Liedtke   ******
;******                                                         ******
;******                                   created:  22.07.90    ******
;******                                   modified: 15.03.97    ******
;******                                                         ******
;*********************************************************************
 

  public init_ipcman
  public init_sndq
  public init_intr_control_block
  public ipcman_open_tcb
  public ipcman_close_tcb
  public ipcman_wakeup_tcb
  public restart_poll_all_senders
  public detach_intr
  public push_ipc_state
  public pop_ipc_state
  public cancel_if_within_ipc
  public get_bottom_state
  public ipc_update_small_space_size

  public ipc_sc
  public id_nearest_sc



  extrn deallocate_resources:near
  extrn switch_context:near
  extrn dispatch:near
  extrn insert_into_ready_list:near
  extrn define_idt_gate:near
  extrn mask_hw_interrupt:near
  extrn map_or_grant_fpage:near
  extrn irq0_intr:abs
  extrn irq15:abs
  


.nolist
include l4const.inc
include uid.inc
include adrspace.inc
include intrifc.inc
.list
include tcb.inc
.nolist
include schedcb.inc
include cpucb.inc
include pagconst.inc
include pagmac.inc
.list
include msg.inc
.nolist
include small-as.inc
include syscalls.inc
include perfmon.inc
.list


ok_for pentium



  assume ds:codseg



;----------------------------------------------------------------------------
;
;20.02.95 jl:  flexpage messages (temp mapping) introduced
;
;
;----------------------------------------------------------------------------




;----------------------------------------------------------------------------
;
;       interrupt associated threads
;
;----------------------------------------------------------------------------






intr_control_block struc

                          db offset intr_cb dup (?)
 
  intr_associated_tcb     dd intr_sources dup (?)

intr_control_block ends 
 



;----------------------------------------------------------------------------
;
;       init intr control block
;
;----------------------------------------------------------------------------
;
;       EAX   bit n = 0 : intr usable
;                   = 1 : intr reserved for kernel
;
;----------------------------------------------------------------------------


  icode


init_intr_control_block:

  pushad

  sub   ecx,ecx
  DO
        shr   eax,1
        sbb   ebx,ebx
        mov   [(ecx*4)+intr_associated_tcb],ebx

        inc   ecx
        cmp   ecx,intr_sources
        REPEATB
  OD

  popad
  ret


  icod  ends



;----------------------------------------------------------------------------
;
;       send ques
;
;----------------------------------------------------------------------------
; send que INVARIANT:
;
;       All tcbs in send ques are present in RAM !!!
;
;       (So insert/delete will never induce paging!)
;       (Swapping out such a tcb must delete it from the que.)
;
;----------------------------------------------------------------------------




;----------------------------------------------------------------------------
;
;       init send que
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBP   tcb write addr
;
;       DS    linear space
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       send que of tcb initialized empty
;
;----------------------------------------------------------------------------


init_sndq:

  push  ebp
  and   [ebp+resources],NOT is_polled
  add   ebp,offset sndq_root
  mov   [ebp].tail,ebp
  mov   [ebp].head,ebp
  pop   ebp
  ret



;----------------------------------------------------------------------------
;
;       insert last into send que
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBP   send que, (write addr of tcb)
;       EBX   tcb of thread to be entered
;
;       DS    linear space
;
;       interrupts disabled
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       EAX,EDX,EDI   scratch
;
;       EBX thread entered into EBP send que
;
;----------------------------------------------------------------------------


insert_last_into_sndq macro

 or  [ebp+resources],is_polled

 lea edi,[ebp+sndq_root]
 lea edx,[ebx+sndq_llink]
 mov eax,[edi].tail

 mov [edi].tail,edx
 mov [edx].pred,eax
 mov [eax].succ,edx
 mov [edx].succ,edi

 endm


;----------------------------------------------------------------------------
;
;       insert intr first into send que
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBP   send que, (write addr of tcb)
;       EDX   intr id
;
;       DS    linear space
;
;       interrupts disabled
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       EAX,ECX,EDX   scratch
;
;       intr id entered into EDX send que
;
;----------------------------------------------------------------------------


insert_intr_first_into_sndq macro

 or  [ebp+resources],is_polled

 lea edx,[(edx*8)+intrq_llink-8*1]
 lea ecx,[ebp+sndq_root]

 mov [edx].pred,ecx
 mov eax,[ecx].head
 mov [ecx].head,edx
 mov [edx].succ,eax
 mov [eax].pred,edx

 endm


.erre   offset intrq_llink GE (offset tcb_space+tcb_space_size)



;----------------------------------------------------------------------------
;
;       get first from send que
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBX   send que, (write addr of tcb)    must not be empty !!
;
;       interrupts disabled
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       C:    EDX   deleted first thread (tcb write addr), BL undefined !
;
;       NC:   EDX   deleted first intr (intr_tab_addr)
;
;       ECX,ESI     scratch
;
;----------------------------------------------------------------------------


get_first_from_sndq macro

 lea esi,[ebx+sndq_root]
 mov edx,[esi].head
 mov ecx,[edx].succ

 mov [esi].head,ecx
 mov [ecx].pred,esi

 IFZ ecx,esi
     and [ebx+resources],NOT is_polled
 FI

 cmp edx,offset intrq_llink

 endm




;----------------------------------------------------------------------------
;
;       test intr in send que
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       reg   send que, (write addr of tcb)    must not be empty !!
;
;       DS    linear space
;
;       interrupts disabled
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       C:    no intr waiting
;
;       NC:   intr waiting in send que (first position)
;
;----------------------------------------------------------------------------


test_intr_in_sndq macro reg

 cmp [reg+sndq_root],offset intrq_llink

 endm





;----------------------------------------------------------------------------
;
;       delete from send que
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBP   to be deleted, (tcb write addr), must be within a snd que!
;
;       interrupts disabled
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       EAX,ECX   scratch
;
;       EBP thread deleted from send que
;
;----------------------------------------------------------------------------


delete_from_sndq macro

 mov eax,[ebp+sndq_llink].succ
 mov ecx,[ebp+sndq_llink].pred

 mov [eax].pred,ecx
 mov [ecx].succ,eax

 IFZ eax,ecx
     and [eax+resources-offset sndq_root],NOT is_polled
 FI

 endm



;----------------------------------------------------------------------------
;
;       join send ques
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBP   tcb of source sndq (not empty)
;       EDI   tcb of dest sndq (may be empty)
;
;       DS    linear space
;
;       interrupts disabled
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       EAX,EBX,ECX,EDX,ESI   scratch
;
;       source sndq empty, old joined to des sndq
;
;----------------------------------------------------------------------------


join_sndqs macro

 and [ebp+resources],NOT is_polled
 or  [edi+resources],is_polled

 lea eax,[edi+sndq_root]
 mov ebx,[edi+sndq_root].tail

 lea esi,[ebp+sndq_root]
 mov ecx,[esi].head
 mov ebp,[esi].tail

 mov [esi].head,esi
 mov [esi].tail,esi

 mov [eax].tail,ebp
 mov [ebp].succ,eax
 mov [ebx].succ,ecx
 mov [ecx].pred,ebx

 endm










;||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
  kcode


;****************************************************************************
;*****                                                                 ******
;*****                                                                 ******
;*****              Interrupt Handling                                 ******
;*****                                                                 ******
;*****                                                                 ******
;****************************************************************************







   ;     align 16


 irp irq,<0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15>

   ;     align 8

intr_&irq:
 push eax
 mov al,irq
 jmp short send_intr

  endm
  
  
.list


  

  ;      align 16



send_intr:

 ke 'INTR' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  push  ecx
  push  edx
  
  push  ebx
  push  ebp
  
  and   eax,0FFh  
  mov   ebp,offset intr_associated_tcb 
  
  push  esi
  push  edi
    
  mov   ebp,ss:[(eax*4)+ebp]
  mov   edx,esp
  
  and   edx,-sizeof tcb
  add   eax,40h
    
  mov   ebx,ss:[ebp+thread_state]
  mov   ecx,eax
     
  xor   eax,ebx   
  jg    intr_pending
  
  mov   ss:[ebp+rem_timeslice],100 ;;;;;;;;;;;;;;;;;; --------------
   
  mov   edi,ebp
  mov   ebp,edx
  
  and   edi,mask thread_no
  
  sub   edi,ebp

  cmp   edx,dispatcher_tcb
  IF____xc z,intr_while_dispatching

  ELSE__
        mark__interrupted ebp
        push  offset switch_from_intr+PM
  FI____


  push  ecx
  sub   ebx,ebx
  
  push  ebx
  mov   esi,ecx
  
  sub   eax,eax
  jmp   ipc_post
  



  
XHEAD intr_while_dispatching

  mov   ebp,ss:[cpu_esp0]   ;;;;;;;;;; no longer correct
  mov   edi,edx
  
  and   ebp,-sizeof tcb
  and   edi,mask thread_no
  
  mov   esp,[ebp+thread_esp]
  sub   edi,ebp
  xret 

 ;; pop   eax
 ;;
 ;; sub   eax,eax          ;;;
 ;; mov   ebx,eax             ;
 ;; mov   esi,edx              ;
 ;; mov   edi,ebx               ;
 ;;                              ;
 ;; iretd                         ;




intr_pending:
 
  test_intr_in_sndq ebp                        ; prevents multiple entry
  IFC                                          ; of intr into sendq
        insert_intr_first_into_sndq

        IFZ   [ebp+thread_state],ready
        CANDNZ ebp,edx
        CANDNZ edx,dispatcher_tcb

              mov   edi,ebp
              mov   ebp,edx
              
              mark__interrupted ebp

              push  offset switch_from_intr+PM
              jmp   switch_context
        FI
  FI

; jmp   switch_from_intr



  klign 16




switch_from_intr:

  lea   eax,[esp+sizeof iret_vec+7*4]
  mov   ebp,offset cpu_esp0
  
  pop   edi
  pop   esi
  
  mov   ss:[ebp],eax
  pop   ebp
  
  pop   ebx
  pop   edx
  
  pop   ecx
  pop   eax
  
  iretd

  
  

;****************************************************************************
;*****                                                                 ******
;*****                                                                 ******
;*****              IPC System Calls                                   ******
;*****                                                                 ******
;*****                                                                 ******
;****************************************************************************






;----------------------------------------------------------------------------
;
;       IPC
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EAX   control word
;       ECX   -ud-
;       EDX   snd.w0
;       EBX   snd.w1
;       EBP   rcv descriptor
;       ESI   source   
;       EDI   dest
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       EAX   completion code
;       ECX   -ud-
;       EDX   msg.w0
;       EBX   msg.w1
;       EBP   -ud-
;       ESI   source
;       EDI   -ud- / true dest
;
;----------------------------------------------------------------------------




  align 16




X = offset tcb_space

Y = (offset gdt - linear_space)


ipc_sc:
          
          
  push  ebp
  mov   ebp,-sizeof tcb
  
  and   ebp,esp
  mov   ecx,edi
  
  and	edi,mask thread_no
  jz	receive_only

  sub   edi,ebp
  mov   ss:[ebp+rcv_descriptor],esi
  
  push  edx    
  mov   edx,ss:[ebp+chief]  
  
  xor   ecx,ss:[edi+ebp+myself+X]
  xor   edx,ss:[edi+ebp+chief+X]
  
  or    edx,ecx
  xc    nz,to_chief,long
  
  mov   edx,ss:[edi+ebp+thread_state]
  mov   esi,ss:[ebp+myself]
  
  xor   ecx,edx
  jg    pending                                ; S or Z => ok, not pending  (note xor: ov=0)
  
  test  al,al
  xc    nz,complex_ipc,long


ipc_post:
 
  mov   edx,fs

  mov   ecx,gs
  
  mov   ch,ss:[ebp+resources]
  mov   ss:[edi+ebp+thread_state+X],edx
  
  or    ecx,edx
  pop   edx
  
  mov   ss:[ebp+thread_esp],esp
  pop   ecx
  
  mov   ss:[edi+ebp+thread_state+X],ecx
  xc    nz,deallocate_resources_or_bad_segments    

  test  ecx,ecx
  xc    z,send_only
  
  mov   esp,ss:[edi+ebp+thread_esp+X]
  mov   ecx,ss:[edi+ebp+thread_proot+X]  
  
  mov   ebp,linear_space
  lea   edi,[esp+iret_vec+4] 

  test  ecx,ecx   
  xc    ns,switch_to_large_address_space

  mov   byte ptr ss:[ebp+linear_space/8*8+1+Y],ch
  mov   byte ptr ss:[ebp+linear_space_exec/8*8+1+Y],ch
  
  mov   ss:[ebp+cpu_esp0-offset gdt+Y],edi
  mov   ch,0F3h
  
  mov   dword ptr ss:[ebp+linear_space/8*8+4+Y],ecx
  mov   ch,0FBh
  
  mov   dword ptr ss:[ebp+linear_space_exec/8*8+4+Y],ecx    
  pop   edi
  
  mov   ds,ebp
  
  mov   es,ebp


  iretd
  




XHEAD send_only

  pop   esi
  pop   ecx
  
  push  offset send_ok_ret+PM
  push  ecx
  
  push  esi
  mov   ecx,ss:[ebp+chief]
  
  test  ss:[ebp+list_state],is_ready
  xret  nz,long

  IFDEF ready_llink
        call  insert_into_ready_list
  ELSE
        lins__ss ebp,esi,ready
  ENDIF
  xret  ,long


  
  
XHEAD deallocate_resources_or_bad_segments 

  test  ch,is_polled
  
  mov   ecx,edi
  IFNZ
        cmp   [ebp+thread_state],0
        jg    fetch_next
  FI      

  lea   edi,[ebp+edi+X]
  call  deallocate_resources
  
  mov   edi,ecx
  
  sub   ecx,ecx
  
  xret  ,long
  
  

XHEAD switch_to_large_address_space

  IFNZ  <ss:[ebp+cpu_cr3-offset gdt+Y]>,ecx
           
        mov   ss:[ebp+cpu_cr3-offset gdt+Y],ecx
        mov   dword ptr ss:[ebp+tlb_invalidated-offset gdt+Y],ecx
            
        mov   cr3,ecx
  FI
        
  mov   ecx,00CCFF00h
  xret  ,long






send_ok_ret:

  sub   eax,eax
  iretd




;----------------------------------------------------------------------------
;
;       Complex IPC
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EAX   control word
;       ECX   -ud-
;       EDX   -ud-
;       EBX   snd.w1
;       EBP   current tcb address
;       ESI   myself
;       EDI   dest tcb address - EBP - offset tcb_space
;
;       tcb.ipc_control         control word
;       tcb.rcv_descriptor      rcv descriptor
;       tcb.thread_state        source
;
;       [ESP]                   snd.w0
;       [ESP+4]                 snd.w2
;
;       SS    linear kernel space
;       DS    linear space (!)
;
;----------------------------------------------------------------------------
;
; POSTCONDITION = PRECONDITION
;
;----------------------------------------------------------------------------



XHEAD complex_ipc

  mov   ecx,eax
  mov   edx,eax

  and   eax,ipc_control_mask
  IFNZ  
 
        mov   edx,ss:[ebp+thread_state]
        push  edi
        
        mov   ss:[ebp+thread_state],ready
        lea   ebp,[ebp+edi+X]
        
        push  edx
        test  al,mem_msg+deceit
        
        mov   ss:[ebp+thread_state],locked
        xc    nz,mem_or_deceit_pre,long
  
        mov   edi,[ebp+rcv_descriptor]
        push  linear_kernel_space
              
        pop   ds  
        
        test  al,map_msg
        IF____xc nz,ipc_map,long
        ELSE__
              test  al,mem_msg
              xc    nz,ipc_mem,long
        FI____
              
        mov   ebp,esp
        pop   ecx
        
        and   ebp,-sizeof tcb      
        pop   edi
        
        nop
        nop        
        
        mov   edx,[ebp+ipc_control]
        mov   [ebp+thread_state],ecx

        mov   ecx,edx
        mov   esi,[ebp+myself]
  FI
  
  shr   cl,4        
  xret  z,long            
  
  
  

enter_receive_timeout:

  
  and   edx,0FF000000h
  add   cl,2
  
  shr   edx,cl
  mov   ch,wakeup_active
  
  shr   edx,cl
  IFNZ

        mov   [ebp+aux_state],ch
        add   edx,ss:[system_clock_low]
        
        mov   [ebp+wakeup_low],edx

        cmp   cl,5+2
        xret  le,long

        movi  edx,<offset soon_wakeup_link>
        cmp   cl,7+2
        mov   cl,is_soon_wakeup
        IFLE
              add   edx,offset late_wakeup_link-soon_wakeup_link
              mov   cl,is_late_wakeup
        FI

        test  ss:[ebp+list_state],cl
        xret  nz,long

        linsr_ss ebp,ecx,edx,cl
        xret  ,long
  FI


  mark__ready ebp
  xret 	,long
  
  






;-------------------------------------------------------------
;
;           IPC MAP
;
;-------------------------------------------------------------
; PRECONDITION:
;
;       EAX   control word
;       ECX   -ud-
;       EDX   -ud-
;       EBX   snd.w1
;       ESI   snd vector address / -ud-
;       EDI   rcv fpage
;       EBP   dest tcb address
;
;       tcb.ipc_control         control word
;       tcb.rcv_descriptor      rcv descriptor
;       tcb.thread_state        ready
;
;       [ESP]                   -ud-
;       [ESP+1*4]               -ud-
;       [ESP+2*4]               snd.w0
;       [ESP+3*4]               snd.w2
;
;       DS    linear kernel space
;
;--------------------------------------------------------------
 
 

XHEAD ipc_map


  test  edi,map_msg
  IFNZ
  mov   edx,ebp                       ;
  xor   edx,esp                       ;
  and   edx,mask task_no              ; ignore intra-task mapping
  CANDNZ

        mov   edx,[esp+2*4]
  
        push  eax
        push  ebx
        call  map_or_grant_fpage
        pop   ebx
        pop   eax
  
        test  al,mem_msg
        xret  z,long
  
        push  ebx
        mov   ecx,[esi+msg_dope]
  
        shr   ecx,md_mwords
        DO
              test  al,ipc_error_mask
              EXITNZ
              add   esi,sizeof fpage_vector
              sub   ecx,sizeof fpage_vector/4
              EXITBE
                     
              push  ecx
              mov   edx,[esi+msg_w2-sizeof fpage_vector].snd_base
              mov   ebx,[esi+msg_w2-sizeof fpage_vector].snd_fpage
              push  eax
              call  map_or_grant_fpage
              pop   eax
              pop   ecx
              REPEAT
        OD  
        pop   ebx
  ELSE_
        add   al,ipc_cut
  FI
  
  xret  ,long                 






XHEAD shorten_mwords

  mov   ecx,edi
  shl   eax,width md_mwords
  shrd  eax,ecx,width md_mwords
  or    al,ipc_cut
  xret  ,long










XHEAD mem_or_deceit_pre

 ke 'y';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 push  ebp

 mov   esi,ss:[esp+iret_esp+(4+2+1)*4]
 mov   esi,ds:[esi]
 mov   ss:[ebp+virtual_sender],esi
 call  nchief
 
 pop   ebp
 xret  ,long













  align 16




XHEAD ipc_mem

  
  mov   esi,eax
  and   al,ipc_control_mask
  
  mov   edi,[ebp+rcv_descriptor]
  and   esi,NOT (deceit+map_msg)
  
  nop
  IFNZ
        mov   bl,al
        mov   eax,[esi+msg_dope]
        
        mov   al,bl
        mov   bl,0
  FI


  test  edi,map_msg
  IFZ   ,,long

  test  eax,mask md_mwords-(2 SHL md_mwords)+mask md_strings + map_msg
  xret  z,long

  add   al,ipc_cut
  and   edi,NOT (deceit+map_msg)
  
  nop
  CANDNZ ,,long


        sub   al,ipc_cut
        push  ebx
        
        push  eax
        mov   ecx,eax
        
        shr   ecx,md_mwords
        mov   [ebx+com_partner],ebp
        
        mov   [ebx+aux_state],ipc_mem_active
        
        mov   al,byte ptr ds:[gdt+linear_space/8*8+4]
        mov   ah,byte ptr ds:[gdt+linear_space/8*8+7]
        
        test  ah,ah
        xc    nz,prepare_small_source,long
               
        mov   [ebp+com_partner],ebx
        mov   eax,ebp

        shr   eax,task_no
        lea   edx,[ecx*4+edi]
        
        sass__32 cmp,edx,MB4-offset msg_w2        
        nop
        
        mov   eax,[ebp+task_pdir]      
        IFBE
        
        test  al,al
        CANDNZ
              mov   ah,0
              add   edi,offset small_virtual_spaces
              
              shl   eax,22
              nop
              
              add   edi,eax              
        ELSE_
        
              mov   al,0
              mov   edx,ds:[cpu_cr3]
              
              cmp   eax,edx
              IFNZ
              
                    mark__ressource ebx,com_used
                    
                    mov   [ebx+waddr],edi
                    mov   ebx,edi
                    
                    and   ebx,-MB4
                    and   edi,MB4-1
                    
                    shr   ebx,20
                    add   eax,PM
                    
                    add   ebx,eax
                    mov   al,ds:[tlb_invalidated]
                    
                    add   edi,com0_base
                    test  al,al
                    
                    mov   eax,[ebx]
                    mov   ebx,[ebx+4]
                    
                    lea   edx,[edx+(com0_base SHR 20)+PM]
                    IFNZ
                    
                          or    al,page_accessed+page_dirty
                          or    bl,page_accessed+page_dirty
                          
                          cmp   [edx],eax
                          CORNZ
                          
                          cmp   [edx+4],ebx
                          IFNZ
                                push  eax
                                mov   eax,cr3
                                mov   cr3,eax
                                pop   eax
                          FI
                    FI      
                    or    al,page_accessed+page_dirty
                    or    bl,page_accessed+page_dirty
                          
                    mov   [edx],eax
                    mov   [edx+4],ebx
              FI                
        FI   

        sti

        mov   edx,edi
        mov   edi,[edi+msg_size_dope]
        
        shr   edi,md_mwords
        nop
        
        cmp   ecx,edi
        xc    a,shorten_mwords,long
        
        sub   ecx,2
        IFA
              lea   esi,[esi+msg_w2]
              
              mov   edi,[edx+32]
              lea   edi,[edx+msg_w2]
              
              cmp   ecx,8
              ccall a,copy_long
           
              DO
                    mov   eax,[esi]
                    mov   [edi],eax
                    
                    add   esi,4
                    add   edi,4
                    
                    dec   ecx
                    REPEATNZ
              OD      

              sub   edi,edx
              sub   esi,edi
        FI


        pop   eax
        pop   ebx
        
        test  ah,mask md_strings SHR 8
        xc    nz,ipc_strings,long

        unmrk_ressource ebx,com_used

        cli

        mov   [ebx+aux_state],0

  FI

  xret  ,long









XHEAD prepare_small_source

  shl   eax,16
  lea   edx,[ecx*4+esi]
  
  sass__32 cmp,edx,MB4-offset msg_w2
  IFB_
        add   esi,eax
        xret  ,long
  FI
  
  mov   eax,[ebx+task_pdir]
  mov   ds:[cpu_cr3],eax
  mov   ds:[tlb_invalidated],al
  mov   cr3,eax
  xret  ,long
  
  
  
        

                                          
               copy_long:
               
               
                    DO
                          mov   eax,[esi]
                          mov   ebx,[edi+32]
                          mov   ebx,[esi+4]
                          mov   [edi],eax
                          mov   [edi+4],ebx
                          mov   eax,[esi+8]
                          mov   ebx,[esi+12]
                          mov   [edi+8],eax
                          mov   [edi+12],ebx
                          mov   eax,[esi+16]
                          mov   ebx,[esi+20]
                          mov   [edi+16],eax
                          mov   [edi+20],ebx
                          mov   eax,[esi+24]
                          mov   ebx,[esi+28]
                          mov   [edi+24],eax
                          mov   [edi+28],ebx
                          add   esi,32
                          add   edi,32
                          sub   ecx,8
                          cmp   ecx,8
                          REPEATA
                    OD
                    ret


              align 16



XHEAD ipc_strings

  mov   ch,ah
  and   ch,mask md_strings SHR 8
;;  mov   cl,[edx+msg_size_dope].msg_strings
  and   cl,mask md_strings SHR 8
  IFA   ch,cl
        mov   ch,cl
        or    al,ipc_cut
        and   ah,NOT (mask md_strings SHR 8)
        add   ah,cl
        test  cl,cl
        xret  z,long
  FI

  push  edx

  mov   edi,[edx+msg_size_dope]
  shr   edi,md_mwords
  lea   edi,[(edi*4)+edx+msg_w2]

  mov   edx,[esi+msg_size_dope]
  shr   edx,md_mwords
  lea   esi,[(edx*4)+esi+msg_w2]

  DO
        push  ecx
        push  esi
        push  edi

        mov   ecx,[esi+str_len]
        cmp   ecx,[edi+buf_size]
        IFA
              mov   ecx,[edi+buf_size]
              or    al,ipc_cut
        FI
        mov   esi,[esi+str_addr]
        mov   edi,[edi+buf_addr]

        push  eax
        push  ebx
        
        mov   edx,ebx
        xor   edx,ebp
        test  edx,mask task_no
        IFNZ
              mov   edx,edi
              and   edx,-MB4
              sub   edi,edx
              add   edi,com0_base
              mov   eax,[ebx+waddr]
              xor   eax,edx
              test  eax,-MB4
              xc    nz,string_to_com1_space
        FI

        mov   dl,cl
        and   dl,4-1
        shr   ecx,2
        
        cmp   ecx,8
        ccall a,copy_long
           
        DO
              mov   eax,[esi]
              mov   [edi],eax
                    
              add   esi,4
              add   edi,4
                    
              dec   ecx
              REPEATNZ
        OD  
        DO
              test  dl,dl
              EXITZ
              mov   al,[esi]
              mov   [edi],al
              cmp   dl,2
              EXITB
              mov   al,[esi+1]
              mov   [edi+1],al
              EXITZ
              mov   al,[esi+2]
              mov   [edi+2],al
        OD
        
        pop   ebx
        pop   eax            
        
        pop   edi
        pop   esi
        pop   ecx

        add   esi,sizeof string_vector
        add   edi,sizeof string_vector
        dec   ch
        REPEATNZ
  OD

  pop   edx
  sub   edi,edx
  sub   esi,edi
  xret  ,long



XHEAD string_to_com1_space

  push  ecx

  mark__ressource ebx,com_used

  shr   edx,16
  mov   word ptr [ebx+waddr],dx
  add   edi,com1_base-com0_base
;;;;;;;;  lea___pdir ecx,ebp
  mov   ecx,[ecx+edx]
  mov   edx,ecx
  and   dl,NOT page_user_permit
  xchg  ds:[pdir+(com1_base SHR 20)],edx
  cmp   edx,ecx
  mov   dword ptr ds:[pdir+(com1_base SHR 20)+4],0

  pop   ecx
  xret  z,long
  test  edx,edx
  xret  z,long

  mov   edx,cr3
  mov   cr3,edx
  xret  ,long







        align 16



fetch_next:

  push  linear_kernel_space
  pop   ds
  
  mov   ebx,ebp
  lea   ebp,[ebp+esi+X]
  

  mov   esi,[ebx+myself]
  mov   edi,[ebx+chief]
  test  al,deceit
  IFNZ
        mov   esi,[ebx+virtual_sender]
        mov   edi,[ebx+virtual_sender+4]
  FI
  mov   ecx,esp
  mov   esp,[ebp+thread_esp]

  push  eax                     ; eax          ;
  mov   eax,[ebx+thread_state]                 ;
  push  eax                     ; ecx          ;
  push  edx                     ; edx          ;
  mov   eax,[ecx]                              ;
  push  eax                     ; ebx          ; pushad
  push  eax                     ; temp (esp)   ;
  push  eax                     ; ebp (scratch);
  push  esi                     ; esi          ;
  push  edi                     ; edi          ;
  push  offset received_ok_ret+PM

  mark__ready ebp

  mov   [ebp+thread_esp],esp
  lea   esp,[ecx+4]


  get_first_from_sndq

  IFC
        mov   dl,0
        mov   ebp,edx

        mov   [edx+thread_state],ready
        mov   [ebx+com_partner],edx
        mov   [ebx+thread_state],locked

        mov   ebp,ebx
        mov   edi,edx
        
        jmp   switch_context
        
  FI

  sub   edx,offset intrq_llink-1*8
  shr   edx,3
  sub   ebx,ebx
  mov   esi,edx
  mov   edi,ebx

  sub   eax,eax
  iretd








ipc_dest_not_existent:

  sub   eax,eax
  mov   al,ipc_not_existent_or_illegal
  pop   ebp
  pop   ebp
  pop   ebp
  iretd



nil_dest_not_existent:

  sub   eax,eax
  mov   al,ipc_not_existent_or_illegal
  pop   edx
  pop   ebx
  pop   ebp
  iretd




  align 16


XHEAD to_chief

 ke 'z';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  test  esi,esi
  jz    nil_dest_not_existent
  
  DO
        mov   ebp,[ebx+chief]
        xor   ebp,edi
        test  ebp,mask site_no
        IFZ
              xor   ebp,edi
              xor   ebp,esi
              test  ebp,mask task_no
              EXITZ

              mov   ebp,[ebx+myself]
              xor   ebp,edi
              test  ebp,mask task_no
              EXITZ
        
        mov   ebp,edi
        or    ebp,NOT mask depth
        sub   ebp,[ebx+chief]
        CANDNC
        shr   ebp,32 - width depth
        CANDA ebp,1
              dec   ebp
              DO
                    lea___tcb edi,edi
                    mov   esi,[edi+myself]
                    mov   edi,[edi+chief]
                    dec   ebp
                    REPEATNZ
              OD
              mov   ebp,[ebx+myself]
              xor   ebp,edi
        ;;      or    al,redirected
              test  ebp,mask thread_no
              EXITZ
        FI

    ;;    or    al,redirected+from_inner_clan
        mov   ebp,[ebx+chief]
        lea___tcb ebp,ebp
        mov   esi,[ebp+myself]
        mov   edi,[ebp+chief]
        
  OD

  lea___tcb ebp,esi
  
  xret  ,long




  align 16


pending:
 
  test  esi,esi
  pop   ecx
  
  pop   esi
  jz    sw_err3
 
  test  eax,0F0h
  IFNZ
        test  eax,000FF0000h
        jz    send_timeout_ret
  FI
  
  push  linear_kernel_space
  pop   ds
  
  push  eax                        ; eax          ;
  push  ss:[ebp+rcv_descriptor]    ; ecx          ;
  push  ecx                        ; edx          ;
  push  ebx                        ; ebx          ;
  
  mov   ebx,ebp
  lea   ebp,[ebp+edi+X]

  push  ebx                        ; temp (esp)   ;
  push  esi                        ; ebp          ;
  mov   esi,[ebx+thread_state]     ;              ;
  xor   edx,[ebp+myself]           ;
  push  esi                        ; esi          ;
  push  edx                        ; edi          ;


  mov   [ebx+com_partner],ebp
  mov   ecx,eax

  insert_last_into_sndq

  shl   ecx,8
  mov   cl,ch
  shr   cl,4

  mov   [ebx+thread_state],polling

  call  wait_for_ipc_or_timeout




  push  linear_kernel_space
  pop   ds

  mov   ebx,esp
  and   ebx,-sizeof tcb
  mov   ebp,[ebx+com_partner]

  IFZ   [ebx+thread_state],ready

        mov   eax,[ebx+myself]
        mov   [ebp+thread_state],eax

        popad
        jmp   ipc_sc

  FI

  IFZ   [ebx+thread_state],polling
        mov   ebp,ebx
        delete_from_sndq
        mov   [ebx+thread_state],ready
  FI

  popad
  
  
  
send_timeout_ret:
  sub   eax,eax
  mov   al,ipc_timeout+ipc_s
  iretd





sw_err3:
  sub   eax,eax
  mov   al,ipc_not_existent_or_illegal
  iretd






;----------------------------------------------------------------------------
;
;       RECEIVE
;
;----------------------------------------------------------------------------


  align 16






  
receive_only:


  push  linear_kernel_space
  pop   ds
  
  mov   ebx,ebp  

  pop   edx

  cmp   ecx,virtual_space_size
  jae   w_err
  
  mov   [ebx+rcv_descriptor],ecx


  cmp   esi,waiting_any
  jnz   receive_from

  test  [ebx+resources],is_polled
  IFNZ

        get_first_from_sndq

        IFNC
              sub   edx,offset intrq_llink-1*8
              pop   eax
              shr   edx,3
              sub   ebx,ebx
              mov   esi,edx
              mov   edi,ebx
              sub   eax,eax

              iretd
        FI

        mov   dl,0
        mark__ready edx
        mov   [ebx+thread_state],locked
        mov   [ebx+com_partner],edx
        mov   [edx+thread_state],ready
        mov   [edx+com_partner],ebx
        mov   ebp,ebx
        mov   edi,edx
        jmp   switch_context
        
  FI





wait_for_receive_or_timeout:

  mov   ebp,ebx



wait_for_receive_from_or_timeout:

  mov   [ebp+thread_state],esi

  and   cl,0Fh
  IFNZ
        mov   edi,ecx
        and   edi,0FF000000h
        jz    short receive_timeout_ret	
  FI

		

wait_for_ipc_or_timeout:

  IFNZ	
        add   cl,2
        shr   edi,cl
        shr   edi,cl
        add   edi,ds:[system_clock_low]
        mov   [ebx+wakeup_low],edi
        or    [ebx+aux_state],wakeup_active
        
        cmp   cl,5+2
        IFG
              movi  edi,<offset soon_wakeup_link>
              cmp   cl,7+2
              mov   cl,is_soon_wakeup
              IFLE
                    add   edi,offset late_wakeup_link-soon_wakeup_link
                    mov   cl,is_late_wakeup
              FI
        test  [ebx+list_state],cl
        CANDZ
              linsr ebx,eax,edi,cl
        FI
  FI

  mov   al,[ebp+timeslice]
  mov   [ebp+rem_timeslice],al

  cmp   [ebp+thread_state],ready
  mov   edi,ebp
  mov   ebp,ebx
  jz    switch_context
  jmp   dispatch





receive_timeout_ret:

  mov   ebp,esp
  pop   eax
  
  and   ebp,-sizeof tcb

  movi  eax,ready
  mov   [ebp+thread_state],eax

  mov   al,ipc_timeout          ; eax<8..31> = 0

  iretd



  align 16


received_ok_ret:

  popad
  iretd






;----------------------------------------------------------------------------
;
;       RECEIVE FROM
;
;----------------------------------------------------------------------------


  align 16


receive_from:

  IFB_  esi,intr_sources+1

        test  esi,esi
        IFNZ
              test_intr_in_sndq ebx

              IFC
                    mov   edi,ecx
                    and   edi,0FF00000Fh
                    IFNZ
                          cmp   edi,15
                    FI
                    jae   wait_for_receive_or_timeout

                    call  detach_intr
                    mov   ecx,esi
                    dec   ecx
                    IFNS
                    CANDZ [(ecx*4)+intr_associated_tcb],0
                          call  attach_intr
                          jmp   receive_timeout_ret
                    FI
                    jmp   w_err
              FI


              get_first_from_sndq

              sub   edx,offset intrq_llink-1*8
              pop   eax
              shr   edx,3
              sub   ebx,ebx
              mov   esi,edx
              mov   edi,ebx
              sub   eax,eax

              iretd
        FI
        
        
        add   esi,waiting_none
        jmp   wait_for_receive_or_timeout
              
  FI

  lea___tcb ebp,esi
  mov   edi,[ebx+chief]
  IFNZ  [ebp+chief],edi
        call  nchief
        lea___tcb ebp,esi
  FI

  cmp   [ebp+myself],esi
  jnz   short r_source_not_existent

  mov   [ebx+thread_state],esi

  IFZ   [ebp+thread_state],polling
  CANDZ [ebp+com_partner],ebx

        delete_from_sndq

        mov   [ebp+thread_state],ready
        mark__ready ebp
        mov   [ebx+thread_state],locked
        mov   [ebx+com_partner],ebp

        mov   edi,ebp
        mov   ebp,ebx
        
        jmp   switch_context
        
  FI
  
  jmp   wait_for_receive_from_or_timeout




 
r_source_not_existent:
  sub   eax,eax
  mov   al,ipc_not_existent_or_illegal
  iretd


;----------------------------------------------------------------------------



w_err:
  pop   eax
  sub   eax,eax
  mov   al,ipc_not_existent_or_illegal
  iretd




;----------------------------------------------------------------------------
;
;       nchief
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       ESI   thread (low)   / 0
;       EDI   thread (high)  / undef
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
; ESI=0 on input:
;
;       ESI   myself (low)
;       EDI   myself (high)
;
;
; ESI>0 on input:
;                        outside clan                       within clan
;
;       AL    redirected / redirected+from_inner_clan             0
;       ESI              chief (low)                        thread (low)
;       EDI              chief (high)                       thread (high)
;
;       ECX,EDX     scratch
;
;----------------------------------------------------------------------------



        align 16




id_nearest_sc:

  mov   ebp,esp
  and   ebp,-sizeof tcb

  sub   eax,eax

  test  esi,esi
  IFZ
        mov   esi,[ebp+myself]
        mov   edi,[ebp+chief]

        iretd
  FI

  mov   ebx,ebp
  push  linear_kernel_space
  pop   ds

  sub   eax,eax
  call  nchief

  push  linear_space
  pop   ds

  iretd



  align 16


nchief:
 
  mov   al,0

  DO
        mov   ebp,[ebx+chief]
        xor   ebp,edi
        test  ebp,mask site_no
        IFZ

              mov   ebp,[ebx+chief]
              xor   ebp,esi
              test  ebp,mask task_no
              EXITZ
              mov   ebp,[ebx+myself]
              xor   ebp,edi
              test  ebp,mask task_no
              EXITZ

              mov   ebp,edi
              sub   ebp,[ebx+chief]
              IFNC
              shr   ebp,32 - width depth
              CANDA ebp,1
                    dec   ebp
                    DO
                          lea___tcb edi,edi
                          mov   esi,[edi+myself]
                          mov   edi,[edi+chief]
                          dec   ebp
                          REPEATNZ
                    OD
                    mov   ebp,[ebx+myself]
                    xor   ebp,edi
                    test  ebp,mask thread_no
                    IFZ
       ;;                   mov   al,redirected+from_inner_clan
                          ret
                    FI
              FI
        FI

        mov   esi,[ebx+chief]
        lea___tcb ebp,esi
        mov   esi,[ebp+myself]
        mov   edi,[ebp+chief]
    ;;    mov   al,redirected
  OD

  ret






  kcod ends
;||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||






;----------------------------------------------------------------------------
;
;       push / pop complete ipc state
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBP   tcb addr
;
;       interrupts disabled !
;
;----------------------------------------------------------------------------
; push PRECONDITION:
;
;       <EBP+fine_state>  is 'locked_running' or 'locked_waiting'
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       pushed / popped
;
;       EAX,EDI  scratch
;
;----------------------------------------------------------------------------
; push POSTCONDITION:
;
;       NZ:   ECX   timeouts for page fault RPC
;
;        Z:         PF timeout is 0, ECX scratch
;
;
;       <EBP+fine_state>  is 'ready'
;
;----------------------------------------------------------------------------

        align 16



push_ipc_state:

  pop   edi

  mov   eax,[ebp+com_partner]
  push  eax
  movi  eax,ready
  xchg  eax,[ebp+thread_state]
  push  eax
  mov   eax,[ebp+rcv_descriptor]
  push  eax
  mov   eax,[ebp+ipc_control]
  push  eax
  mov   al,[ebp+state_sp]
  push  eax

  mov   eax,esp
  shr   eax,2
  mov   [ebp+state_sp],al

  mov   ecx,[ebp+com_partner]
;;  test  [ebp+fine_state],nrcv
;;  mov   ecx,[ecx+timeouts]
  IFNZ
        rol   ch,4
  FI
  mov   cl,ch
  and   cl,0F0h
  shr   ch,4
  or    cl,ch
  mov   ch,cl
  rol   ecx,16
  mov   cl,1
  mov   ch,1
  ror   ecx,16
  cmp   cl,15*16+15

  jmp   edi






pop_ipc_state:

  pop   edi

  pop   eax
  mov   [ebp+state_sp],al
;;  mov   [ebp+fine_state],ah
  shr   eax,8
;;  mov   byte ptr [ebp+timeouts+1],ah

  pop   eax
  mov   [ebp+rcv_descriptor],eax
  pop   eax
  mov   [ebp+thread_state],eax
  pop   eax
  mov   [ebp+com_partner],eax

;;  test  [eax+fine_state],nlock
  IFZ
  CANDZ [eax+com_partner],ebp

        jmp   edi
  FI


  ke    '-pi_err'






;----------------------------------------------------------------------------
;
;       get bottom state
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBP   tcb write addr
;
;       interrupts disabled !
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       EAX   fine state (bottom)
;       EBX   com partner (bottom) iff state is 'locked'
;
;----------------------------------------------------------------------------



get_bottom_state:

  movzx eax,[ebp+state_sp]
  test  eax,eax
  IFZ 
        mov   eax,[ebp+kernel_stack_bottom-sizeof int_pm_stack].ip_error_code 
        IFAE  eax,min_icode
        CANDBE eax,max_icode
 
              mov   eax,ready
              ret 
        FI
 
        mov   eax,[ebp+thread_state]
        ret
  FI

 ke 'complex_get_bottom_state' 
  DO
        lea   ebx,[(eax*4)+ebp]
        mov   al,[ebx]
        test  al,al
        REPEATNZ
  OD
  mov   al,[ebx+1]
  mov   ebx,[ebx+4*4]
  ret
 




;----------------------------------------------------------------------------
;
;       cancel if within ipc
;
;----------------------------------------------------------------------------
; cancel if within ipc PRECONDITION:
;
;       EBP   tcb write addr
;
;       interrupts disabled !
;
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       AL    bottom state
;
;       {REGs - AL}    scratch
;
;       base waiting   :   ipc cancelled
;       base pending   :   ipc cancelled
;       base locked    :   ipc aborted, also of partner
;
;       ELSE           :   status unchanged
;
;----------------------------------------------------------------------------



cancel_if_within_ipc:

  IFZ   [ebp+thread_state],polling    
        push  eax
        push  ecx
        delete_from_sndq
        pop   ecx
        pop   eax
  FI      


  call  get_bottom_state

  push  eax
  
  IFNZ  eax,locked
  test  [ebp+aux_state],ipc_mem_active
  CANDZ
        IFNZ  eax,ready
              mov   al,ipc_cancelled
              call  reset_ipc
        FI
        pop   eax
        ret
  FI

  mov   al,ipc_aborted
  call  reset_ipc
  mov   ebp,ebx
  mov   al,ipc_aborted
  call  reset_ipc

  pop   eax
  ret





reset_ipc:

  pop   ecx

  lea   esi,[ebp+kernel_stack_bottom-sizeof iret_vec-2*4]
  IFZ   [ebp+thread_state],ready
        add   al,ipc_s
  FI
  movzx eax,al
  mov   [esi+4],eax
  mov   dword ptr [esi],offset reset_ipc_ret

  mov   [ebp+thread_state],ready
  mov   ebx,ebp
  mark__ready ebx
  
  mov   [ebp+thread_esp],esi
  xor   esi,esp
  test  esi,mask thread_no
  IFZ
        xor   esp,esi
  FI

  jmp   ecx





reset_ipc_ret:

  pop   eax
  iretd




;----------------------------------------------------------------------------
;
;       ipcman wakeup tcb
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBP   tcb write addr
;
;       DS    linear space
;
;       interrupts disabled !
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       if locked no change, else
;       state of thread set to 'ready', deleted from sendq if necessary
;
;----------------------------------------------------------------------------




ipcman_wakeup_tcb:

 ke 'adopt_ifc_ebp_ebx'
 
 ;; test  [ebp+fine_state],nlock
  IFNZ
        push  eax
		push  ecx
		push	edi
        
    ;;    test  [ebp+fine_state],npoll
        IFZ
              delete_from_sndq
		ELSE_
			mov	edi,[ebp+thread_esp]
			sub	edi,4
			mov	[ebp+thread_esp],edi
			mov	dword ptr [edi],offset receive_timeout_ret
        FI
     ;;   mov   [ebp+fine_state],running
        mark__ready  ebp
        
        pop   edi
        pop	ecx
        pop   eax
  FI

  ret


;----------------------------------------------------------------------------
;
;       ipcman open tcb
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBP   tcb write addr, must be mapped !!
;
;       DS    linear space
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       EDP   reentered into snd que if necessary
;
;----------------------------------------------------------------------------




ipcman_open_tcb:
 
  pushfd
  cli

 ;; test  [ebp+fine_state],npoll
 ;; IFZ
 ;;       call  enforce_restart_poll
 ;; FI

  popfd
  ret


;----------------------------------------------------------------------------
;
;       ipcman close tcb
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBP   to be deleted, (tcb write addr)
;             must be mapped !!
;
;       DS    linear space
;
;----------------------------------------------------------------------------
; POSTCONDITION:
;
;       EBP thread deleted from send que if contained
;
;----------------------------------------------------------------------------



ipcman_close_tcb:
 
  pushad
  pushfd

  cli

  mov   eax,[ebp+thread_state]

  IFZ   eax,polling
        delete_from_sndq
  ;;;;; lno___thread ebx,eBp
  ;;;;; call  signal_scheduler_reactivation
  FI

  mov   eax,[ebp+sndq_root].head
  and   eax,-sizeof tcb
  IFNZ  eax,ebp

;;;;    mov   edi,scheduler_tcb
;;;;    join_sndqs
  FI

  popfd
  popad
  ret




;----------------------------------------------------------------------------
;
;       restart poll all senders          (special routine for schedule)
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBX   tcb address
;
;----------------------------------------------------------------------------


restart_poll_all_senders:
 
  ke '-n'

; pushad
; pushfd
;
; DO
;       cli
;       test  [ebx+resources],is_polled
;       EXITZ
;
;       get_first_from_sndq
;       IFNC
;             ke    'flushed_intr'
;       FI
;       mov   dl,0
;
;       test  [edx+fine_state],npoll
;       IFZ
;             mov   ebp,edx
;             call  enforce_restart_poll
;       FI
;
;       sti
;       REPEAT
; OD
;
; popfd
; popad
; ret



;----------------------------------------------------------------------------
;
;       enforce restart poll
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBP   tcb address, mapped
;
;       tcb not open AND fine state = polling
;
;----------------------------------------------------------------------------


enforce_restart_poll:
 
  pushad

 ke 'no'
;;  lea___esp eax,ebp
;;mov   dword ptr [eax],offset restart_poll

  mov   ebx,ebp
  mark__ready ebx

;;  mov   al,running
;;  xchg  [ebp+fine_state],al

;;  test  al,nwake
  IFZ
        mov   esi,[ebp+wakeup_low]
        movzx edi,[ebp+wakeup_high]
        pushfd
        cli
        mov   eax,ds:[system_clock_low]
        movzx ebx,ds:[system_clock_high]
        popfd                                  ; Rem: change of NT impossible

        sub   esi,eax
        sbb   edi,ebx
        IFC                                    ;Ž92-12-08
              sub   esi,esi
        FI
        mov   [ebp+ipc_control],esi            ;..Ž
  FI

  popad
  ret




;----------------------------------------------------------------------------
;
;       attach interrupt
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBX   tcb write addr
;       ECX   intr no  (0...intr_sources-1)
;
;----------------------------------------------------------------------------


attach_intr:
 
  mov   [(ecx*4)+intr_associated_tcb],ebx
  
  IF    kernel_x2
        push  eax
        lno___prc eax
        test  eax,eax
        pop   eax
        IFNZ
              push  eax
              push  ebx
              
              lea   eax,[ecx*2+io_apic_redir_table]
              mov   byte ptr ds:[io_apic+io_apic_select_reg],al
              lea   ebx,[ecx+irq0_intr]
           mov ebx,10000h  
              mov   ds:[io_apic+io_apic_window],ebx
              inc   al
              mov   byte ptr ds:[io_apic+io_apic_select_reg],al
              mov   eax,ds:[local_apic+apic_id]
              mov   ds:[io_apic+io_apic_window],eax
              
              mov   eax,offset intr_1 - offset intr_0
              imul  eax,ecx
              add   eax,offset intr_0_P2 + PM
              lea   ebx,[ecx+irq0_intr]
              mov   bh,0 SHL 5
              call  define_idt_gate
              
              extrn p6_workaround_open_irq:near
              call  p6_workaround_open_irq
              
              pop   ebx
              pop   eax
              ret
        FI
  ENDIF            
              

  call  mask_hw_interrupt

  push  eax
  push  ebx
  mov   eax,offset intr_1 - offset intr_0
  imul  eax,ecx
  add   eax,offset intr_0 + PM
  lea   ebx,[ecx+irq0_intr]
  mov   bh,0 SHL 5
  call  define_idt_gate
  pop   ebx
  pop   eax

  ret



;----------------------------------------------------------------------------
;
;       detach interrupt
;
;----------------------------------------------------------------------------
; PRECONDITION:
;
;       EBX   tcb write addr
;
;----------------------------------------------------------------------------


detach_intr:
 
  push  ecx

  sub   ecx,ecx
  DO
        IFZ   [ecx+intr_associated_tcb],ebx
              mov   [ecx+intr_associated_tcb],0
              shr   ecx,2
              call  mask_hw_interrupt
              EXIT
        FI
        add   ecx,4
        cmp   ecx,sizeof intr_associated_tcb
        REPEATB
  OD

  pop   ecx
  ret





;----------------------------------------------------------------------------
;
;       update small_space_size
;
;----------------------------------------------------------------------------

.listmacro


ipc_update_small_space_size:

  update_small_space_size_immediates
  
  ret
  
  
  
.nolistmacro  
  

;----------------------------------------------------------------------------
;
;       V2 IPC emulator
;
;----------------------------------------------------------------------------


ipc_v2_sc:

  mov   edi,esi
  IFAE  eax,virtual_space_size      
        sub   edi,edi
        sub   eax,eax
  ELSE_      
        test  eax,NOT 11b
        IFNZ
              ke    'v2_ipc_mem'
        FI      
  FI
  
  test  ebp,1
  IFNZ
        dec   ebp
        mov   esi,waiting_any
  FI
  
  ror   ecx,16
  shr   ch,2
  shr   cx,2
  rol   ecx,16
  
  or    eax,ecx
  mov   ecx,ebp
  
  int   ipc3
  
  lea___tcb ebp,esi
  
  lea   edi,[esp+sizeof iret_vec]
  mov   ss:[cpu_esp0],edi
  
  mov   edi,ss:[ebp+chief]
  
  iretd
              



;----------------------------------------------------------------------------
;
;       init ipcman
;
;----------------------------------------------------------------------------


  icode



init_ipcman:

  mov   bh,3 SHL 5

  mov   bl,ipc3
  mov   eax,offset ipc_sc+PM
  call  define_idt_gate
  
  mov   bl,ipc
  mov   eax,offset ipc_v2_sc+PM
  call  define_idt_gate

  mov   bl,id_nearest
  mov   eax,offset id_nearest_sc+PM
  call  define_idt_gate

  ret



  icod  ends




  code ends
  end
